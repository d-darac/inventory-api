// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createItem = `-- name: CreateItem :one
INSERT INTO items 
(
    id,
    created_at,
    updated_at,
    active,
    description,
    name,
    type,
    account_id,
    group_id
)
VALUES 
(
    gen_random_uuid(),
    NOW(),
    NOW(),
    TRUE,
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING
    id,
    created_at,
    updated_at,
    active,
    description,
    name,
    type,
    group_id AS group
`

type CreateItemParams struct {
	Description sql.NullString
	Name        string
	Type        ItemType
	AccountID   uuid.UUID
	GroupID     uuid.NullUUID
}

type CreateItemRow struct {
	ID          uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Active      bool
	Description sql.NullString
	Name        string
	Type        ItemType
	Group       uuid.NullUUID
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (CreateItemRow, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.Description,
		arg.Name,
		arg.Type,
		arg.AccountID,
		arg.GroupID,
	)
	var i CreateItemRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Active,
		&i.Description,
		&i.Name,
		&i.Type,
		&i.Group,
	)
	return i, err
}

const deleteItem = `-- name: DeleteItem :exec

DELETE FROM items
WHERE id = $1 AND account_id = $2
`

type DeleteItemParams struct {
	ID        uuid.UUID
	AccountID uuid.UUID
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteItem, arg.ID, arg.AccountID)
	return err
}

const getItem = `-- name: GetItem :one

SELECT
    id,
    created_at,
    updated_at,
    active,
    description,
    name,
    type,
    group_id AS group
FROM items
WHERE id = $1 AND account_id =$2
`

type GetItemParams struct {
	ID        uuid.UUID
	AccountID uuid.UUID
}

type GetItemRow struct {
	ID          uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Active      bool
	Description sql.NullString
	Name        string
	Type        ItemType
	Group       uuid.NullUUID
}

func (q *Queries) GetItem(ctx context.Context, arg GetItemParams) (GetItemRow, error) {
	row := q.db.QueryRowContext(ctx, getItem, arg.ID, arg.AccountID)
	var i GetItemRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Active,
		&i.Description,
		&i.Name,
		&i.Type,
		&i.Group,
	)
	return i, err
}

const listItems = `-- name: ListItems :many

SELECT
    id,
    created_at,
    updated_at,
    active,
    description,
    name,
    type,
    group_id AS group
FROM items
WHERE account_id = $1
AND
    (
        $2::timestamp IS NULL 
        OR $2::timestamp > created_at
    )
AND 
    (
        $3::timestamp IS NULL 
        OR $3::timestamp < created_at
    )
AND 
    (
        $4::timestamp IS NULL 
        OR $4::timestamp >= created_at
    )
AND 
    (
        $5::timestamp IS NULL 
        OR $5::timestamp <= created_at
    )
AND 
    (
        $6::timestamp IS NULL 
        OR $6::timestamp > updated_at
    )
AND 
    (
        $7::timestamp IS NULL 
        OR $7::timestamp < updated_at
    )
AND 
    (
        $8::timestamp IS NULL 
        OR $8::timestamp >= updated_at
    )
AND 
    (
        $9::timestamp IS NULL 
        OR $9::timestamp <= updated_at
    )
AND 
    (
        $10::uuid IS NULL
        OR $10::uuid > id
    )
AND 
    (
        $11::uuid IS NULL
        OR $11::uuid < id
    )
AND
    (
        $12::boolean IS NULL
        OR active = $12::boolean
    )
AND 
    (
        $13::text IS NULL 
        OR description LIKE $13::text
    )
AND 
    (
        $14::uuid IS NULL 
        OR group_id = $14::uuid
    )
AND 
    (
        $15::text IS NULL 
        OR name LIKE $15::text
    )
AND
    (
        $16::item_type IS NULL 
        OR name LIKE $16::item_type
    )
ORDER BY created_at DESC
LIMIT COALESCE($17::int, 10)
`

type ListItemsParams struct {
	AccountID     uuid.UUID
	CreatedAtGt   sql.NullTime
	CreatedAtLt   sql.NullTime
	CreatedAtGte  sql.NullTime
	CreatedAtLte  sql.NullTime
	UpdatedAtGt   sql.NullTime
	UpdatedAtLt   sql.NullTime
	UpdatedAtGte  sql.NullTime
	UpdatedAtLte  sql.NullTime
	StartingAfter uuid.NullUUID
	EndingBefore  uuid.NullUUID
	Active        sql.NullBool
	Description   sql.NullString
	GroupID       uuid.NullUUID
	Name          sql.NullString
	Type          NullItemType
	Limit         sql.NullInt32
}

type ListItemsRow struct {
	ID          uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Active      bool
	Description sql.NullString
	Name        string
	Type        ItemType
	Group       uuid.NullUUID
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems,
		arg.AccountID,
		arg.CreatedAtGt,
		arg.CreatedAtLt,
		arg.CreatedAtGte,
		arg.CreatedAtLte,
		arg.UpdatedAtGt,
		arg.UpdatedAtLt,
		arg.UpdatedAtGte,
		arg.UpdatedAtLte,
		arg.StartingAfter,
		arg.EndingBefore,
		arg.Active,
		arg.Description,
		arg.GroupID,
		arg.Name,
		arg.Type,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Active,
			&i.Description,
			&i.Name,
			&i.Type,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateItem = `-- name: UpdateItem :one

UPDATE items
SET
    updated_at = NOW(),
    active = COALESCE($1, active),
    description = COALESCE($2, description),
    name = COALESCE($3, name),
    group_id = COALESCE($4, group_id)
WHERE id = $5 AND account_id = $6
RETURNING
    id,
    created_at,
    updated_at,
    active,
    description,
    name,
    type,
    group_id AS group
`

type UpdateItemParams struct {
	Active      sql.NullBool
	Description sql.NullString
	Name        sql.NullString
	GroupID     uuid.NullUUID
	ID          uuid.UUID
	AccountID   uuid.UUID
}

type UpdateItemRow struct {
	ID          uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Active      bool
	Description sql.NullString
	Name        string
	Type        ItemType
	Group       uuid.NullUUID
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (UpdateItemRow, error) {
	row := q.db.QueryRowContext(ctx, updateItem,
		arg.Active,
		arg.Description,
		arg.Name,
		arg.GroupID,
		arg.ID,
		arg.AccountID,
	)
	var i UpdateItemRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Active,
		&i.Description,
		&i.Name,
		&i.Type,
		&i.Group,
	)
	return i, err
}
