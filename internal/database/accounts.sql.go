// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts 
(
    id,
    created_at,
    updated_at,
    country,
    deleted,
    nickname,
    owner_id
)
VALUES 
(
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1,
    FALSE,
    $2,
    $3
)
RETURNING
    id,
    created_at,
    updated_at,
    country,
    nickname,
    owner_id AS owner
`

type CreateAccountParams struct {
	Country  Countries
	Nickname sql.NullString
	OwnerID  uuid.NullUUID
}

type CreateAccountRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Country   Countries
	Nickname  sql.NullString
	Owner     uuid.NullUUID
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (CreateAccountRow, error) {
	row := q.db.QueryRowContext(ctx, createAccount, arg.Country, arg.Nickname, arg.OwnerID)
	var i CreateAccountRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
		&i.Nickname,
		&i.Owner,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec

UPDATE accounts
SET
    updated_at = NOW(),
    deleted = TRUE,
    owner_id = NULL
WHERE id = $1 AND owner_id = $2
`

type DeleteAccountParams struct {
	ID      uuid.UUID
	OwnerID uuid.NullUUID
}

func (q *Queries) DeleteAccount(ctx context.Context, arg DeleteAccountParams) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, arg.ID, arg.OwnerID)
	return err
}

const getAccount = `-- name: GetAccount :one

SELECT
    id,
    created_at,
    updated_at,
    country,
    nickname,
    owner_id AS owner
FROM accounts
WHERE id = $1 AND owner_id = $2
`

type GetAccountParams struct {
	ID      uuid.UUID
	OwnerID uuid.NullUUID
}

type GetAccountRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Country   Countries
	Nickname  sql.NullString
	Owner     uuid.NullUUID
}

func (q *Queries) GetAccount(ctx context.Context, arg GetAccountParams) (GetAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getAccount, arg.ID, arg.OwnerID)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
		&i.Nickname,
		&i.Owner,
	)
	return i, err
}

const listAccountsByOwnerId = `-- name: ListAccountsByOwnerId :many

SELECT
    id,
    created_at,
    updated_at,
    country,
    nickname,
    owner_id AS owner
FROM accounts
WHERE owner_id = $1
ORDER BY created_at DESC
LIMIT COALESCE($2, 10)
`

type ListAccountsByOwnerIdParams struct {
	OwnerID uuid.NullUUID
	Limit   interface{}
}

type ListAccountsByOwnerIdRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Country   Countries
	Nickname  sql.NullString
	Owner     uuid.NullUUID
}

func (q *Queries) ListAccountsByOwnerId(ctx context.Context, arg ListAccountsByOwnerIdParams) ([]ListAccountsByOwnerIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountsByOwnerId, arg.OwnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByOwnerIdRow
	for rows.Next() {
		var i ListAccountsByOwnerIdRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Country,
			&i.Nickname,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountsByUserId = `-- name: ListAccountsByUserId :many

SELECT
    accounts.id,
    accounts.created_at,
    accounts.updated_at,
    accounts.country,
    accounts.nickname,
    accounts.owner_id AS owner
FROM accounts
JOIN accounts_users 
ON accounts.id = accounts_users.account_id
WHERE accounts_users.user_id = $1
ORDER BY accounts.created_at DESC
LIMIT COALESCE($2, 10)
`

type ListAccountsByUserIdParams struct {
	UserID uuid.UUID
	Limit  interface{}
}

type ListAccountsByUserIdRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Country   Countries
	Nickname  sql.NullString
	Owner     uuid.NullUUID
}

func (q *Queries) ListAccountsByUserId(ctx context.Context, arg ListAccountsByUserIdParams) ([]ListAccountsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccountsByUserId, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByUserIdRow
	for rows.Next() {
		var i ListAccountsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Country,
			&i.Nickname,
			&i.Owner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one

UPDATE accounts
SET
    updated_at = NOW(),
    country = COALESCE($1, country),
    nickname = COALESCE($2, nickname)
WHERE id = $3 AND owner_id = $4
RETURNING
    id,
    created_at,
    updated_at,
    country,
    nickname,
    owner_id AS owner
`

type UpdateAccountParams struct {
	Country  NullCountries
	Nickname sql.NullString
	ID       uuid.UUID
	OwnerID  uuid.NullUUID
}

type UpdateAccountRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Country   Countries
	Nickname  sql.NullString
	Owner     uuid.NullUUID
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (UpdateAccountRow, error) {
	row := q.db.QueryRowContext(ctx, updateAccount,
		arg.Country,
		arg.Nickname,
		arg.ID,
		arg.OwnerID,
	)
	var i UpdateAccountRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
		&i.Nickname,
		&i.Owner,
	)
	return i, err
}
